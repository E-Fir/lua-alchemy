{ // start of pass-thru C section
/*
** This is the generated file produced from lua_wrapper.gg
** Wrapper for Lua.
**
*/

#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>

/* Include the Lua API header files. */
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

/* AS3.h is included automatically by gluegen */

void sztrace(char*);

/* Some global variables initialized in ggInit() */
AS3_Val no_params = NULL;
AS3_Val zero_param = NULL;
AS3_Val ByteArray_class = NULL;

/* Helper function get an actionscript class with the given namespace and class name */
static AS3_Val get_class(const char *as_class_path)
{
  char *class_ptr = strrchr(as_class_path, '.');
  if (class_ptr == NULL)
    return AS3_Null();
  
  AS3_Val as_namespace = AS3_StringN(as_class_path, (class_ptr - as_class_path)/sizeof(char));
  AS3_Val as_class = AS3_String(class_ptr+1);

  AS3_Trace(as_namespace);
  AS3_Trace(as_class);
  
  AS3_Val ret = AS3_NSGet(as_namespace, as_class);

	AS3_Release(as_namespace);
	AS3_Release(as_class);

	return ret;
}

/* Create an ActionScript array from the lua stack values */
static AS3_Val create_as3_array_from_lua_stack(lua_State *L, int start, int end)
{
  AS3_Val array = AS3_Array("");
  const char *value;
  int i;
  for (i = start; i <= end; i++)
  {
    value = lua_tostring(L, i);
    /* TODO create the proper AS3 type based on the type in the stack */
    AS3_CallS("push", array, AS3_Array("StrType", value));
  }
  return array;
}

static void clear_lua_stack(lua_State *L)
{
  int i;
  i = lua_gettop(L);
  for (i = lua_gettop(L); i > 0; i--)
    lua_remove(L, i);
}

static int as3_class(lua_State *L)
{
  sztrace("as3_class()");
  return 0;
}

static int as3_new(lua_State *L)
{
  sztrace("as3_new()");
  return 0;
}

static int as3_release(lua_State *L)
{
  sztrace("as3_release()");
  return 0;
}

static int as3_get(lua_State *L)
{
  sztrace("as3_get()");
  return 0;
}

static int as3_set(lua_State *L)
{
  sztrace("as3_set()");
  return 0;
}

static int as3_call(lua_State *L)
{
  sztrace("as3_call()");
  return 0;
}

static int as3_yield(lua_State *L)
{
  sztrace("as3_new()");
  return 0;
}

static int as3_stage(lua_State *L)
{
  sztrace("as3_stage()");
  return 0;
}

static const luaL_reg AS3_LUA_LIB[] =
{
  { "as3Class", as3_class },
  { "as3New", as3_new },
  { "as3Release", as3_release },
  { "as3Get", as3_get },
  { "as3Set", as3_set },
  { "as3Call", as3_call },
  { "as3Yield", as3_yield },
  { "as3Stage", as3_stage },
  { NULL, NULL } /* The end */
};

/* 
  Creates the lua context, opens the standard libs, and registers functions
*/
static lua_State * create_context()
{
  lua_State *lua_ctx;
	lua_ctx = lua_open();
  luaL_openlibs(lua_ctx);
  luaL_register(lua_ctx, "as3", AS3_LUA_LIB);
  clear_lua_stack(lua_ctx); /* TODO the call above put something on the stack */
  return lua_ctx;
}

/* This function will be called at the top of the generated main(). The GGINIT_DEFINED macro is required. */
#define GGINIT_DEFINED true
static void ggInit()
{
	sztrace("setting up lua_wrapper library");

	/* setup some useful constants */
	no_params = AS3_Array("");
	zero_param = AS3_Int(0);
	ByteArray_class = get_class("flash.utils.ByteArray");
}


/* end of passthru C section */
}

public function luaCreateContext():(lua_State *)uint
{
  return create_context();
}

public function luaClose(lua_ctx:(lua_State *)uint):void
{
  lua_close(lua_ctx);
}

public function luaDoString(lua_ctx:(lua_State *)uint, str:String):(AS3_Val)Array
{
  sztrace(str);
  int status;

  status = luaL_dostring(lua_ctx, str);  
  return create_as3_array_from_lua_stack(lua_ctx, 1, lua_gettop(lua_ctx));
}
