{ /* start of pass-thru C section */
/*
** This is the generated file produced from lua_wrapper.gg
** Wrapper for Lua.
**
*/

#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>

/* Include the Lua API header files. */
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#include "lstack.h"

/* AS3.h is included automatically by gluegen */

void sztrace(char *);

/* Some global variables initialized in ggInit() */
AS3_Val no_params = NULL;
AS3_Val zero_param = NULL;
AS3_Val Number_class = NULL;
AS3_Val int_class = NULL;
AS3_Val String_class = NULL;
AS3_Val Boolean_class = NULL;
AS3_Val flash_utils_namespace = NULL;
AS3_Val getQualifiedClassName_method = NULL;
AS3_Val Array_class = NULL;

typedef struct AS3LuaUserData
{
  AS3_Val value;
} AS3LuaUserData;

typedef struct LuaFunctionCallbackData
{
  lua_State * L;
  int ref;
} LuaFunctionCallbackData;

#define AS3LUA_METATABLE "LuaAlchemy.as3"

#define check_as3userdata(L, index) \
  (AS3LuaUserData *)luaL_checkudata(L, index, AS3LUA_METATABLE)

/************************************************************
* AS3.h Helper Functions
************************************************************/

/*
* Get an actionscript class with the given namespace and class name
* in the format: package::ClassName
*/
static AS3_Val get_class(const char * as_class_path)
{
  AS3_Val as_namespace;
  AS3_Val as_class;
  char * class_ptr = NULL;

  /* TODO might want to store classes in a table to save loading again */

  class_ptr = strstr(as_class_path, "::");

  if (class_ptr > as_class_path)
  {
    as_namespace = AS3_StringN(as_class_path, (class_ptr - as_class_path) / sizeof(char));
    as_class = AS3_String(class_ptr + 2);
  }
  else
  {
    as_namespace = AS3_Undefined();
    as_class = AS3_String(as_class_path);
  }

  AS3_Val ret = AS3_NSGet(as_namespace, as_class);

  /* TODO check for failure getting class */

  AS3_Release(as_namespace);
  AS3_Release(as_class);

  return ret;
}

/************************************************************
* Lua Helper Functions
************************************************************/

/*
 * BEGIN COPY-PASTE FROM Lua 5.1.4 ldblib.c
 */

static lua_State *getthread (lua_State * L, int *arg) {
  if (lua_isthread(L, 1)) {
    *arg = 1;
    return lua_tothread(L, 1);
  }
  else {
    *arg = 0;
    return L;
  }
}

#define LEVELS1	12	/* size of the first part of the stack */
#define LEVELS2	10	/* size of the second part of the stack */

static int db_errorfb (lua_State * L) {
  int level;
  int firstpart = 1;  /* still before eventual `...' */
  int arg;
  lua_State * L1 = getthread(L, &arg);
  lua_Debug ar;
  if (lua_isnumber(L, arg+2)) {
    level = (int)lua_tointeger(L, arg+2);
    lua_pop(L, 1);
  }
  else
    level = (L == L1) ? 1 : 0;  /* level 0 may be this own function */
  if (lua_gettop(L) == arg)
    lua_pushliteral(L, "");
  else if (!lua_isstring(L, arg+1)) return 1;  /* message is not a string */
  else lua_pushliteral(L, "\n");
  lua_pushliteral(L, "stack traceback:");
  while (lua_getstack(L1, level++, &ar)) {
    if (level > LEVELS1 && firstpart) {
      /* no more than `LEVELS2' more levels? */
      if (!lua_getstack(L1, level+LEVELS2, &ar))
        level--;  /* keep going */
      else {
        lua_pushliteral(L, "\n\t...");  /* too many levels */
        while (lua_getstack(L1, level+LEVELS2, &ar))  /* find last levels */
          level++;
      }
      firstpart = 0;
      continue;
    }
    lua_pushliteral(L, "\n\t");
    lua_getinfo(L1, "Snl", &ar);
    lua_pushfstring(L, "%s:", ar.short_src);
    if (ar.currentline > 0)
      lua_pushfstring(L, "%d:", ar.currentline);
    if (*ar.namewhat != '\0')  /* is there a name? */
        lua_pushfstring(L, " in function " LUA_QS, ar.name);
    else {
      if (*ar.what == 'm')  /* main? */
        lua_pushfstring(L, " in main chunk");
      else if (*ar.what == 'C' || *ar.what == 't')
        lua_pushliteral(L, " ?");  /* C function or tail call */
      else
        lua_pushfstring(L, " in function <%s:%d>",
                           ar.short_src, ar.linedefined);
    }
    lua_concat(L, lua_gettop(L) - arg);
  }
  lua_concat(L, lua_gettop(L) - arg);
  return 1;
}

/*
 * END COPY-PASTE FROM Lua 5.1.4 ldblib.c
 */

#undef LEVELS1
#undef LEVELS2

static int do_pcall_with_traceback(lua_State * L, int narg, int nresults)
{
  int status = 0;
  int base = lua_gettop(L) - narg;  /* function index */

  lua_pushcfunction(L, db_errorfb);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  status = lua_pcall(L, narg, nresults, base);
  lua_remove(L, base);  /* remove traceback function */

  /* force a complete garbage collection in case of errors */
  if (status != 0)
  {
    lua_gc(L, LUA_GCCOLLECT, 0);
  }

  return status;
}

static AS3_Val as3_lua_callback(void *data, AS3_Val args);
static AS3_Val create_as3_value_from_lua_stack(lua_State *L, int start, int end, int collapse_array);
static void push_as3_lua_userdata(lua_State *L, AS3_Val val);
static void push_as3_to_lua_stack(lua_State *L, AS3_Val val);

static int push_as3_array_to_lua_stack(lua_State *L, AS3_Val array)
{
  if (!AS3_InstanceOf(array, Array_class))
    return 0;

  int len = AS3_IntValue(AS3_GetS(array, "length"));
  int i;
  AS3_Val cur;
  for (i = 0; i < len; i++)
  {
    cur = AS3_Get(array, AS3_Int(i));
    push_as3_to_lua_stack(L, cur);
    AS3_Release(cur);
  }

  return len;
}

/*
* Function used as a callback for all Lua functions passed throuhg
* get_as3_value_from_lua_stack()
*/
static AS3_Val as3_lua_callback(void *data, AS3_Val args)
{
  LuaFunctionCallbackData *func_data = (LuaFunctionCallbackData*)data;

  int base = lua_gettop(func_data->L);

  lua_rawgeti(func_data->L, LUA_REGISTRYINDEX, func_data->ref); /* push stored function */
  int nargs = push_as3_array_to_lua_stack(func_data->L, args); /* push arguments */

  /* call function (error checking omitted) */
  /* TODO: call do_pcall_with_traceback; see luaDoString() */
  lua_pcall(func_data->L, nargs,  LUA_MULTRET, 0);

  /* Process results, return stack except for function on the top */
  AS3_Val ret = create_as3_value_from_lua_stack(func_data->L, base + 1, lua_gettop(func_data->L), 1);
  
  return ret;
}

/*
* Take the Lua stack item at index i and convert it into an
* ActionScript value.
*/
static AS3_Val get_as3_value_from_lua_stack(lua_State *L, int i)
{
  AS3_Val value;
  AS3LuaUserData *userdata;
  int t;
  LuaFunctionCallbackData *func_data;

  value = AS3_Undefined();
  t = lua_type(L, i);

  switch (t)
  {
    case LUA_TSTRING:  /* strings */
    {
      size_t length = 0;
      const char * str = lua_tolstring(L, i, &length);
      if (str == NULL)  /* NOTE: This is unreachable. Assert instead */
      {
        length = 6;
        str = "(null)";
      }
      /* NOTE: Alchemy .5a truncates embedded zeroes in string regardless to the passed length */
      value = AS3_StringN(str, length);
    }
      break;

    case LUA_TBOOLEAN:  /* booleans */
      value = lua_toboolean(L, i) ? AS3_True() : AS3_False();
      break;

    case LUA_TNUMBER:  /* numbers */
      value = AS3_Number(lua_tonumber(L, i));
      break;

    case LUA_TNIL:  /* nil */
      value = AS3_Null();
      break;

    case LUA_TUSERDATA:  /* userdata should only be AS3LuaUserData */
      userdata = (AS3LuaUserData *) lua_touserdata(L, i);
      value = userdata->value;
      break;

    case LUA_TFUNCTION: /* function */
      func_data = malloc(sizeof(LuaFunctionCallbackData)); /* TODO cleanup this when function dies */

      lua_pushvalue(L, i);

      func_data->L = L;
      func_data->ref = luaL_ref(L, LUA_REGISTRYINDEX);

      value = AS3_Function(func_data, as3_lua_callback);
      break;

    case LUA_TLIGHTUSERDATA: /* not used */
    case LUA_TTABLE: /* TODO deal with this type */
    case LUA_TTHREAD: /* TODO deal with this type */
      value = AS3_String(lua_typename(L, t));
      break;

    default:  /* unreachable */
      luaL_error(L, "unknown Lua type %d", t);
      break;
  }

  /*
  sztrace("get_as3_value_from_lua_stack()");
  AS3_Trace(AS3_Call(getQualifiedClassName_method, NULL, AS3_Array("AS3ValType", value)));
  */

  return value;
}

/*
* Create an ActionScript value from the lua stack starting
* at index start and ending at index end.  If collapse_array == 1,
* an empty return will be transformed into AS3_Undefined() and a
* return of length 1 will just return the specific value.
* Otherwise an array is returned.
*/
static AS3_Val create_as3_value_from_lua_stack(lua_State *L, int start, int end, int collapse_array)
{
  AS3_Val ret;
  AS3_Val value;
  int i;
  
  /* sztrace("****START create_as3_value_from_lua_stack()"); */
  
  if (collapse_array == 1 && start > end)
  {
    ret = AS3_Null();
  }
  else if (collapse_array == 1 && start == end)
  {
    ret = get_as3_value_from_lua_stack(L, start);
  }
  else
  {
    ret = AS3_Array("");

    for (i = start; i <= end; i++)
    {
      value = get_as3_value_from_lua_stack(L, i);
      AS3_CallS("push", ret, AS3_Array("AS3ValType", value));
    }
  }

  /*
  sztrace("ret type =");
  AS3_Trace(AS3_Call(getQualifiedClassName_method, NULL, AS3_Array("AS3ValType", ret)));
  sztrace("****END create_as3_value_from_lua_stack()");
  */

  return ret;
}

/*
* Take the given ActionScript value and push it onto the
* stack with the correct metatable.
*/
static int push_as3_lua_userdata(lua_State * L, AS3_Val val)
{

  AS3LuaUserData * userdata = NULL;

  AS3_Acquire(val);

  userdata = (AS3LuaUserData *)lua_newuserdata(L, sizeof(AS3LuaUserData));
  userdata->value = val;

  luaL_getmetatable(L, AS3LUA_METATABLE);
  lua_setmetatable(L, -2);
}

/*
* Given an ActionScript object, push it onto the Lua stack as a Lua native
* type if a primitive class (String, Number, Boolean, int, null)
* or push as userdata
*/
static int push_as3_to_lua_stack(lua_State * L, AS3_Val val)
{
  /*
  sztrace("***push_as3_to_lua_stack()");
  AS3_Trace(AS3_Call(getQualifiedClassName_method, NULL, AS3_Array("AS3ValType", val)));
  */
  
  if (AS3_InstanceOf(val, Number_class))
  {
    lua_pushnumber(L, AS3_NumberValue(val));
  }
  else if (AS3_InstanceOf(val, int_class))
  {
    lua_pushnumber(L, AS3_IntValue(val));
  }
  else if (AS3_InstanceOf(val, String_class))
  {
    /* TODO: Release?! */
    AS3_Val lengthVal = AS3_GetS(val, "length");
    size_t length = AS3_IntValue(lengthVal);
    AS3_Malloced_Str str = AS3_StringValue(val);

    lua_pushlstring(L, str, length);
    free(str);
  }
  else if (AS3_InstanceOf(val, Boolean_class))
  {
    lua_pushboolean(L, AS3_IntValue(val));
  }
  else if (val == AS3_Undefined() || val == AS3_Null())
  {
    lua_pushnil(L);
  }
  else
  {
    push_as3_lua_userdata(L, val);
  }
}

/************************************************************
* AS3 functions exported to Lua
************************************************************/

/*
* Release control to Flash and return to this point on the next timer tick
* Lua example: as3.yield()
*/
static int as3_yield(lua_State * L)
{
  flyield();
  return 0;
}

/*
* Return the Flash stage
* Lua example: as3.stage()
*/
static int as3_stage(lua_State * L)
{
  /* TODO: This is currently void, call setSprite() before init() to fix */
  push_as3_lua_userdata(L, AS3_Stage());
  return 1;
}

/*
* Return the requested class in package::ClassName form.
* Can be used to call static class functions
* Lua example: v = as3.class("flash.utils.ByteArray")
*/
static int as3_class(lua_State * L)
{
  const char * classname = NULL;
  AS3_Val as_class;

  classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package::ClassName' expected");

  as_class = get_class(classname);
  luaL_argcheck(L, as_class != NULL, 1, "'package::ClassName' must be valid");

  /* TODO check if get_class failed */

  push_as3_lua_userdata(L, as_class);

  AS3_Release(as_class);

  return 1;
}

/*
* Create a new instance of the given class in package::ClassName form.
* Lua example: v = as3.new("flash.utils.ByteArray")
*/
static int as3_new(lua_State * L)
{
  const char * classname = NULL;
  AS3_Val as_class;
  AS3_Val params;
  AS3_Val as_object;

  classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package::ClassName' expected");

  as_class = get_class(classname);
  /* TODO error if as_class == null */

  params = create_as3_value_from_lua_stack(L, 2, lua_gettop(L), 0);

  as_object = AS3_New(as_class, params);
  /* TODO error if as_object == null, make sure you free the class and params */

  push_as3_lua_userdata(L, as_object);

  AS3_Release(as_object);
  AS3_Release(params);
  AS3_Release(as_class); /* TODO might want to store classes in a table to save loading again */

  return 1;
}

/*
* Release the given ActionScript object so Flash will do garbage collection.
* Lua example: as3.release(v)
*/
static int as3_release(lua_State * L)
{
  AS3LuaUserData * userdata = check_as3userdata(L, 1);

  if (userdata->value != AS3_Undefined())
  {
    AS3_Release(userdata->value);
    userdata->value = AS3_Undefined();
  }

  return 0;
}

/*
* Convert ActionScript to a lua type if possible (see push_as3_to_lua_stack).
* If conversion is not possible, this will return the original AS object
* Lua example: as3.toluatype(v)
*/
static int as3_tolua(lua_State * L)
{
  AS3LuaUserData * userdata = check_as3userdata(L, 1);
  push_as3_to_lua_stack(L, userdata->value);

  return 1;
}

/*
* Return the requested property of a given ActionScript object.  The value
* is returned as a Lua type if possible (see push_as3_to_lua_stack)
* Lua example: as3.get(v, "text")
*/
static int as3_get(lua_State * L)
{
  AS3LuaUserData * userdata = NULL;
  const char * property = NULL;
  AS3_Val val;

  userdata = check_as3userdata(L, 1);

  property = lua_tostring(L, 2);
  luaL_argcheck(L, property != NULL, 2, "'property' expected");

  val = AS3_GetS(userdata->value, property);
  /* TODO check for AS3_GetS successful */

  push_as3_to_lua_stack(L, val);

  AS3_Release(val);

  return 1;
}

/*
* Set the requested property of a given ActionScript object.
* Lua example: as3.set(v, "text", "hello from Lua")
*/
static int as3_set(lua_State * L)
{
  AS3LuaUserData * userdata = NULL;
  const char * property = NULL;
  AS3_Val value;

  userdata = check_as3userdata(L, 1);

  property = lua_tostring(L, 2);
  luaL_argcheck(L, property != NULL, 2, "'property' expected");

  value = get_as3_value_from_lua_stack(L, 3);
  luaL_argcheck(L, value != AS3_Undefined(), 3, "'value' expected");

  AS3_SetS(userdata->value, property, value);
  /* TODO check if AS3_SetS sucessful */

  return 0;
}

/*
* Set a primitive ActionScript value (like String, Number, etc)
* Lua example: as3.assign(v, 5)
*/
static int as3_assign(lua_State * L)
{
  AS3LuaUserData * userdata = 0;
  AS3_Val value;

  userdata = check_as3userdata(L, 1);

  value = get_as3_value_from_lua_stack(L, 2);
  luaL_argcheck(L, value != AS3_Undefined(), 2, "'value' expected");

  /* TODO how to assign the value of a String, Number, int, etc? var s:String; s = "hello"; and do we care? */

  return 0;
}

/*
* Call a function on a given ActionScript object
* Lua example: as3.call(v, "myFunction", "param1", param2, ...)
*/
static int as3_call(lua_State * L)
{
  AS3LuaUserData * userdata = NULL;
  AS3_Val params;
  const char * function_name = NULL;
  AS3_Val result;

  userdata = check_as3userdata(L, 1);

  function_name = lua_tostring(L, 2);
  luaL_argcheck(L, function_name != NULL, 2, "'function_name' expected");

  params = create_as3_value_from_lua_stack(L, 3, lua_gettop(L), 0);

  result = AS3_CallS(function_name, userdata->value, params);
  /* TODO check for function call failure, make sure to relase params */

  AS3_Release(params);

  push_as3_to_lua_stack(L, result);

  AS3_Release(result);

  return 1;
}

/*
* Return the ActionScript qualified name of the given object as a string
* Lua example: as3.type(v)
*/
static int as3_type(lua_State * L)
{
  AS3LuaUserData *userdata;
  AS3_Val result;
  AS3_Val params;

  userdata = check_as3userdata(L, 1);

  params = AS3_Array("AS3ValType", userdata->value);

  result = AS3_Call(getQualifiedClassName_method, NULL, params);
  /* TODO check for failure */

  push_as3_to_lua_stack(L, result);

  AS3_Release(result);
  AS3_Release(params);

  return 1;
}

/*
* Call a namespace function
* Can be used to call namespace functions
* Lua example: v = as3.package("flash.utils", "getQualifiedClassName")
*/
static int as3_namespacecall(lua_State * L)
{
  const char * namespace = NULL;
  const char * function_name = NULL;
  AS3_Val as_namespace;
  AS3_Val as_method;
  AS3_Val params;
  AS3_Val result;

  namespace = lua_tostring(L, 1);
  luaL_argcheck(L, namespace != NULL, 1, "'namespace' expected");

  function_name = lua_tostring(L, 2);
  luaL_argcheck(L, function_name != NULL, 2, "'function_name' expected");

  as_namespace = AS3_String(namespace);
  as_method = AS3_NSGetS(as_namespace, function_name);

  params = create_as3_value_from_lua_stack(L, 3, lua_gettop(L), 0);

  result = AS3_Call(as_method, NULL, params);
  /* TODO check for function call failure, make sure to release as_namespace, as_method, params */

  push_as3_lua_userdata(L, result);

  AS3_Release(result);
  AS3_Release(as_namespace);
  AS3_Release(as_method);
  AS3_Release(params);

  return 1;
}

/*
* AS function registry for Lua
*/
static const luaL_reg AS3_LUA_LIB[] =
{
  { "yield", as3_yield },
  { "stage", as3_stage },
  { "class", as3_class },
  { "new", as3_new },
  { "release", as3_release },
  { "toluatype", as3_toluatype },
  { "get", as3_get },
  { "set", as3_set },
  { "assign", as3_assign },
  { "call", as3_call },
  { "type", as3_type },
  { "namespacecall", as3_namespacecall },
  { NULL, NULL } /* The end */
};

/*
* Creates the lua_state, opens the standard libs, and registers functions
*/
static lua_State * initialize_state()
{
  lua_State * L = lua_open();

  lua_gc(L, LUA_GCSTOP, 0);  /* stop collector during initialization */

  luaL_openlibs(L);

  luaL_newmetatable(L, AS3LUA_METATABLE);
  lua_pushcfunction(L, as3_release);
  lua_setfield(L, -2, "__gc");

  lua_pop(L, 1); /* pop as3 metatable created above */

  luaL_register(L, "as3", AS3_LUA_LIB);
  lua_pop(L, 1); /* pop as3 library table created by above call */

  lua_gc(L, LUA_GCRESTART, 0); /* restart collector */

  return L;
}

/*
* This function will be called at the top of the generated main().
* The GGINIT_DEFINED macro is required.
*/
#define GGINIT_DEFINED true
static void ggInit()
{
  /* setup some useful constants */
  no_params = AS3_Array("");
  zero_param = AS3_Int(0);
  Number_class = get_class("Number");
  int_class = get_class("int");
  String_class = get_class("String");
  Boolean_class = get_class("Boolean");
  flash_utils_namespace = AS3_String("flash.utils");
  getQualifiedClassName_method = AS3_NSGetS(flash_utils_namespace, "getQualifiedClassName");
  Array_class = get_class("Array");
}

/* end of passthru C section */
}

public function luaInitilizeState():(lua_State *)uint
{
  return initialize_state();
}

public function luaClose(luaState:(lua_State *)uint):void
{
  lua_close(luaState);
}

public function luaDoString(luaState:(lua_State *)uint, strValue:(AS3_Val)*):(AS3_Val)Array
{
  int base = 0;
  int status = 0;
  AS3_Malloced_Str str = AS3_StringValue(strValue);

  lua_pushboolean(luaState, 1); /* Placeholder for execution status */
  base = lua_gettop(luaState);

  status = luaL_loadbuffer(
      luaState,
      str,
      AS3_IntValue(AS3_GetS(strValue, "length")),
      "=luaDoString"
    );

  free(str);

  if (!status)
  {
    status = do_pcall_with_traceback(luaState, 0, LUA_MULTRET);
  }

  if (status)
  {
    lua_pushboolean(luaState, 0); /* ERROR */
    lua_replace(luaState, base);
    /* Error message is on stack */
    /* NOTE: It is not necessary string! */
  }

  return create_as3_value_from_lua_stack(luaState, base, lua_gettop(luaState), 0);
}

// TODO: Add luaDoStringThrow()?

public function setGlobal(luaState:(lua_State *)uint, key:String, value:(AS3_Val)*):void
{
  push_as3_to_lua_stack(luaState, value);
  lua_setglobal(luaState, key);
}
