{ /* start of pass-thru C section */
/*
** This is the generated file produced from lua_wrapper.gg
** Wrapper for Lua.
**
*/

#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>

/* Include the Lua API header files. */
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

/* AS3.h is included automatically by gluegen */

void sztrace(char*);

/* Some global variables initialized in ggInit() */
AS3_Val no_params = NULL;
AS3_Val zero_param = NULL;
AS3_Val Number_class = NULL;
AS3_Val int_class = NULL;
AS3_Val String_class = NULL;
AS3_Val Boolean_class = NULL;
AS3_Val flash_utils_namespace = NULL;
AS3_Val getQualifiedClassName_method = NULL;
AS3_Val Array_class = NULL;

typedef struct AS3LuaUserData
{
  AS3_Val value;
} AS3LuaUserData;

typedef struct LuaFunctionCallbackData
{
  lua_State *L;
  int ref;
} LuaFunctionCallbackData;

#define checkas3(L) \
  (AS3LuaUserData*)luaL_checkudata(L, 1, "LuaAlchemy.as3")

/************************************************************
* AS3.h Helper Functions
************************************************************/

/*
* Get an actionscript class with the given namespace and class name
* in the format: package::ClassName
*/
static AS3_Val get_class(const char *as_class_path)
{
  AS3_Val as_namespace;
  AS3_Val as_class;
  char *class_ptr;

  /* TODO might want to store classes in a table to save loading again */

  class_ptr = strstr(as_class_path, "::");

  if (class_ptr > as_class_path)
  {
    as_namespace = AS3_StringN(as_class_path, (class_ptr - as_class_path)/sizeof(char));
    as_class = AS3_String(class_ptr+2);
  }
  else
  {
    as_namespace = AS3_String("");
    as_class = AS3_String(as_class_path);
  }

  AS3_Val ret = AS3_NSGet(as_namespace, as_class);

  /* TODO check for failure getting class */

  AS3_Release(as_namespace);
  AS3_Release(as_class);

  return ret;
}

/************************************************************
* Lua Helper Functions
************************************************************/
static AS3_Val as3_lua_callback(void *data, AS3_Val args);
static AS3_Val create_as3_array_from_lua_stack(lua_State *L, int start, int end);
static void push_as3_lua_userdata(lua_State *L, AS3_Val val);

static int push_as3_array_to_lua_stack(lua_State *L, AS3_Val array)
{
  if (!AS3_InstanceOf(array, Array_class))
    return 0;

  int len = AS3_GetS(array, "length");
  int i;
  AS3_Val cur;
  for (i = 0; i < len; i++)
  {
    cur = AS3_Get(array, AS3_Int(i));
    push_as3_lua_userdata(L, cur);
    AS3_Release(cur);
  }

  return len;
}

/*
* Function used as a callback for all Lua functions passed throuhg
* get_as3_value_from_lua_stack()
*/
static AS3_Val as3_lua_callback(void *data, AS3_Val args)
{
  LuaFunctionCallbackData *func_data = (LuaFunctionCallbackData*)data;
  
  lua_rawgeti(func_data->L, LUA_REGISTRYINDEX, func_data->ref); /* push stored function */
  int nargs = push_as3_array_to_lua_stack(func_data->L, args); /* push arguments */
  
  /* call function (error checking omitted) */
  lua_pcall(func_data->L, nargs,  LUA_MULTRET, 0);

  /* Process results, return stack except for function on the top */  
  AS3_Val ret = create_as3_array_from_lua_stack(func_data->L, 2, lua_gettop(func_data->L));

  return ret;
}

/*
* Take the Lua stack item at index i and convert it into an
* ActionScript value.
*/
static AS3_Val get_as3_value_from_lua_stack(lua_State *L, int i)
{
  AS3_Val value;
  AS3LuaUserData *userdata;
  int t;
  LuaFunctionCallbackData *func_data;

  value = AS3_Undefined();
  t = lua_type(L, i);

  switch (t)
  {
    case LUA_TSTRING:  /* strings */
      value = AS3_String(lua_tostring(L, i));
    break;

    case LUA_TBOOLEAN:  /* booleans */
      value = lua_toboolean(L, i) ? AS3_True() : AS3_False();
      break;

    case LUA_TNUMBER:  /* numbers */
      value = AS3_Number(lua_tonumber(L, i));
      break;

    case LUA_TNIL:  /* nil */
      value = AS3_Null();
      break;

    case LUA_TUSERDATA:  /* userdata should only be AS3LuaUserData */
      userdata = (AS3LuaUserData *) lua_touserdata(L, i);
      value = userdata->value;
      break;

    case LUA_TFUNCTION: /* function */
      func_data = malloc(sizeof(LuaFunctionCallbackData)); /* TODO cleanup this when function dies */

      lua_pushvalue(L, i);

      func_data->L = L;
      func_data->ref = luaL_ref(L, LUA_REGISTRYINDEX);

      value = AS3_Function(func_data, as3_lua_callback);
      break;

    case LUA_TLIGHTUSERDATA: /* not used */
    case LUA_TTABLE: /* TODO deal with this type */
    case LUA_TTHREAD: /* TODO deal with this type */
      value = AS3_String(lua_typename(L, t));
      break;

    default:  /* unreachable */
      luaL_error(L, "unknown Lua type %d", t);
      break;
  }

  /* AS3_Trace(AS3_Call(getQualifiedClassName_method, NULL, AS3_Array("AS3ValType", value))); */

  return value;
}

/*
* Create an ActionScript array from the lua stack values starting
* at index start and ending at index end.
*/
static AS3_Val create_as3_array_from_lua_stack(lua_State *L, int start, int end)
{
  AS3_Val array;
  AS3_Val value;
  int i;

  array = AS3_Array("");

  for (i = start; i <= end; i++)
  {
    value = get_as3_value_from_lua_stack(L, i);
    AS3_CallS("push", array, AS3_Array("AS3ValType", value));
  }

  return array;
}

/*
* Take the given ActionScript value and push it onto the
* stack with the correct metatable.
*/
static void push_as3_lua_userdata(lua_State *L, AS3_Val val)
{
  AS3LuaUserData *userdata;

  AS3_Acquire(val);

  userdata = (AS3LuaUserData *) lua_newuserdata(L, sizeof(AS3LuaUserData));
  userdata->value = val;

  luaL_getmetatable(L, "LuaAlchemy.as3");
  lua_setmetatable(L, -2);
}

/*
* Given an ActionScript object, push it onto the Lua stack as a Lua native
* type if a primitive class (String, Number, Boolean, int, null)
* or push as userdata
*/
static void push_as3_to_lua_stack(lua_State *L, AS3_Val val)
{
  AS3_Malloced_Str str;

  if (AS3_InstanceOf(val, Number_class))
  {
    lua_pushnumber(L, AS3_NumberValue(val));
  }
  else if (AS3_InstanceOf(val, int_class))
  {
    lua_pushnumber(L, AS3_IntValue(val));
  }
  else if (AS3_InstanceOf(val, String_class))
  {
    str = AS3_StringValue(val);
    lua_pushstring(L, str);
    free(str);
  }
  else if (AS3_InstanceOf(val, Boolean_class))
  {
    lua_pushboolean(L, AS3_IntValue(val));
  }
  else if (val == AS3_Undefined() || val == AS3_Null())
  {
    lua_pushnil(L);
  }
  else
  {
    push_as3_lua_userdata(L, val);
  }
}

/************************************************************
* AS3 functions exported to Lua
************************************************************/

/*
* Release control to Flash and return to this point on the next timer tick
* Lua example: as3.yield()
*/
static int as3_yield(lua_State *L)
{
  flyield();
  return 0;
}

/*
* Return the Flash stage
* Lua example: as3.stage()
*/
static int as3_stage(lua_State *L)
{
  sztrace("as3_stage()");
  /* TODO: This is currently void, call setSprite() before init() to fix */
  push_as3_lua_userdata(L, AS3_Stage());
  return 1;
}

/*
* Return the requested class in package::ClassName form.
* Can be used to call static class functions
* Lua example: v = as3.class("flash.utils.ByteArray")
*/
static int as3_class(lua_State *L)
{
  const char *classname;
  AS3_Val as_class;

  classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package::ClassName' expected");

  as_class = get_class(classname);
  luaL_argcheck(L, as_class != NULL, 1, "'package::ClassName' must be valid");

  /* TODO check if get_class failed */

  push_as3_lua_userdata(L, as_class);

  AS3_Release(as_class);

  return 1;
}

/*
* Create a new instance of the given class in package::ClassName form.
* Lua example: v = as3.new("flash.utils.ByteArray")
*/
static int as3_new(lua_State *L)
{
  const char *classname;
  AS3_Val as_class;
  AS3_Val params;
  AS3_Val as_object;

  classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package::ClassName' expected");

  as_class = get_class(classname);
  /* TODO error if as_class == null */

  params = create_as3_array_from_lua_stack(L, 2, lua_gettop(L));

  as_object = AS3_New(as_class, params);
  /* TODO error if as_object == null, make sure you free the class and params */

  push_as3_lua_userdata(L, as_object);

  AS3_Release(as_object);
  AS3_Release(params);
  AS3_Release(as_class); /* TODO might want to store classes in a table to save loading again */

  return 1;
}

/*
* Release the given ActionScript object so Flash will do garbage collection.
* Lua example: as3.release(v)
*/
static int as3_release(lua_State *L)
{
  AS3LuaUserData *userdata;

  userdata = checkas3(L);
  if (userdata->value != AS3_Undefined())
  {
    AS3_Release(userdata->value);
    userdata->value = AS3_Undefined();
  }

  return 0;
}

/*
* Convert ActionScript to a lua type if possible (see push_as3_to_lua_stack).
* If conversion is not possible, this will return the original AS object
* Lua example: as3.toluatype(v)
*/
static int as3_toluatype(lua_State *L)
{
  AS3LuaUserData *userdata;

  userdata = checkas3(L);
  push_as3_to_lua_stack(L, userdata->value);

  return 1;
}

/*
* Return the requested property of a given ActionScript object.  The value
* is returned as a Lua type if possible (see push_as3_to_lua_stack)
* Lua example: as3.get(v, "text")
*/
static int as3_get(lua_State *L)
{
  AS3LuaUserData *userdata;
  const char *property;
  AS3_Val val;

  userdata = checkas3(L);

  property = lua_tostring(L, 2);
  luaL_argcheck(L, property != NULL, 2, "'property' expected");

  val = AS3_GetS(userdata->value, property);
  /* TODO check for AS3_GetS successful */

  push_as3_to_lua_stack(L, val);

  AS3_Release(val);

  return 1;
}

/*
* Set the requested property of a given ActionScript object.
* Lua example: as3.set(v, "text", "hello from Lua")
*/
static int as3_set(lua_State *L)
{
  AS3LuaUserData *userdata;
  const char *property;
  AS3_Val value;

  userdata = checkas3(L);

  property = lua_tostring(L, 2);
  luaL_argcheck(L, property != NULL, 2, "'property' expected");

  value = get_as3_value_from_lua_stack(L, 3);
  luaL_argcheck(L, value != AS3_Undefined(), 3, "'value' expected");

  AS3_SetS(userdata->value, property, value);
  /* TODO check if AS3_SetS sucessful */

  return 0;
}

/*
* Set a primitive ActionScript value (like String, Number, etc)
* Lua example: as3.assign(v, 5)
*/
static int as3_assign(lua_State *L)
{
  AS3LuaUserData *userdata;
  AS3_Val value;

  userdata = checkas3(L);

  value = get_as3_value_from_lua_stack(L, 2);
  luaL_argcheck(L, value != AS3_Undefined(), 2, "'value' expected");

  /* TODO how to assign the value of a String, Number, int, etc? var s:String; s = "hello"; and do we care? */

  return 0;
}

/*
* Call a function on a given ActionScript object
* Lua example: as3.call(v, "myFunction", "param1", param2, ...)
*/
static int as3_call(lua_State *L)
{
  AS3LuaUserData *userdata;
  AS3_Val params;
  const char *function_name;
  AS3_Val result;

  userdata = checkas3(L);

  function_name = lua_tostring(L, 2);
  luaL_argcheck(L, function_name != NULL, 2, "'function_name' expected");

  params = create_as3_array_from_lua_stack(L, 3, lua_gettop(L));

  result = AS3_CallS(function_name, userdata->value, params);
  /* TODO check for function call failure, make sure to relase params */

  AS3_Release(params);

  push_as3_to_lua_stack(L, result);

  AS3_Release(result);

  return 1;
}

/*
* Return the ActionScript qualified name of the given object as a string
* Lua example: as3.type(v)
*/
static int as3_type(lua_State *L)
{
  AS3LuaUserData *userdata;
  AS3_Val result;
  AS3_Val params;

  userdata = checkas3(L);

  params = AS3_Array("AS3ValType", userdata->value);

  result = AS3_Call(getQualifiedClassName_method, NULL, params);
  /* TODO check for failure */

  push_as3_to_lua_stack(L, result);

  AS3_Release(result);
  AS3_Release(params);

  return 1;
}

/*
* Call a namespace function
* Can be used to call namespace functions
* Lua example: v = as3.package("flash.utils", "getQualifiedClassName")
*/
static int as3_namespacecall(lua_State *L)
{
  const char *namespace;
  const char *function_name;
  AS3_Val as_namespace;
  AS3_Val as_method;
  AS3_Val params;
  AS3_Val result;

  namespace = lua_tostring(L, 1);
  luaL_argcheck(L, namespace != NULL, 1, "'namespace' expected");

  function_name = lua_tostring(L, 2);
  luaL_argcheck(L, function_name != NULL, 2, "'function_name' expected");

  as_namespace = AS3_String(namespace);
  as_method = AS3_NSGetS(as_namespace, function_name);

  params = create_as3_array_from_lua_stack(L, 3, lua_gettop(L));

  result = AS3_Call(as_method, NULL, params);
  /* TODO check for function call failure, make sure to release as_namespace, as_method, params */

  push_as3_lua_userdata(L, result);

  AS3_Release(result);
  AS3_Release(as_namespace);
  AS3_Release(as_method);
  AS3_Release(params);

  return 1;
}

/*
* AS function registry for Lua
*/
static const luaL_reg AS3_LUA_LIB[] =
{
  { "yield", as3_yield },
  { "stage", as3_stage },
  { "class", as3_class },
  { "new", as3_new },
  { "release", as3_release },
  { "toluatype", as3_toluatype },
  { "get", as3_get },
  { "set", as3_set },
  { "assign", as3_assign },
  { "call", as3_call },
  { "type", as3_type },
  { "namespacecall", as3_namespacecall },
  { NULL, NULL } /* The end */
};

/*
* Creates the lua_state, opens the standard libs, and registers functions
*/
static lua_State * lua_initialize_state()
{
  lua_State *L;
  L = lua_open();
  luaL_openlibs(L);

  luaL_newmetatable(L, "LuaAlchemy.as3");
  lua_pop(L, 1); /* pop as3 metatable created by above call */

  luaL_register(L, "as3", AS3_LUA_LIB);
  lua_pop(L, 1); /* pop as3 library table created by above call */
    
  return L;
}

/*
* This function will be called at the top of the generated main().
* The GGINIT_DEFINED macro is required.
*/
#define GGINIT_DEFINED true
static void ggInit()
{
  /* setup some useful constants */
  no_params = AS3_Array("");
  zero_param = AS3_Int(0);
  Number_class = get_class("Number");
  int_class = get_class("int");
  String_class = get_class("String");
  Boolean_class = get_class("Boolean");
  flash_utils_namespace = AS3_String("flash.utils");
  getQualifiedClassName_method = AS3_NSGetS(flash_utils_namespace, "getQualifiedClassName");
  Array_class = get_class("Array");
}

/* end of passthru C section */
}

public function luaInitilizeState():(lua_State *)uint
{
  return lua_initialize_state();
}

public function luaClose(luaState:(lua_State *)uint):void
{
  lua_close(luaState);
}

public function luaDoString(luaState:(lua_State *)uint, str:String):(AS3_Val)Array
{
  int status;
  status = luaL_dostring(luaState, str);
  /* TODO handle status */
  return create_as3_array_from_lua_stack(luaState, 1, lua_gettop(luaState));
}

public function setGlobal(luaState:(lua_State *)uint, obj:(AS3_Val)*, name:String):void
{
  push_as3_to_lua_stack(luaState, obj);
  lua_setglobal(luaState, name);
}
