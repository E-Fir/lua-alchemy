{ // start of pass-thru C section
/*
** This is the generated file produced from lua_wrapper.gg
** Wrapper for Lua.
**
*/

#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>

/* Include the Lua API header files. */
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

/* AS3.h is included automatically by gluegen */

void sztrace(char*);

/* Some global variables initialized in ggInit() */
AS3_Val no_params = NULL;
AS3_Val zero_param = NULL;
AS3_Val Number_class = NULL;
AS3_Val int_class = NULL;
AS3_Val String_class = NULL;
AS3_Val Boolean_class = NULL;

typedef struct AS3LuaUserData
{
  AS3_Val value;
} AS3LuaUserData;

/* Helper function get an actionscript class with the given namespace and class name */
static AS3_Val get_class(const char *as_class_path)
{
  char msg[1024];
  sprintf(msg, "get_class %s", as_class_path);
  sztrace(msg);

  /* TODO might want to store classes in a table to save loading again */

  char *class_ptr = strrchr(as_class_path, '.');
  
  AS3_Val as_namespace;
  AS3_Val as_class;
  
  if (class_ptr > as_class_path)
  {
    as_namespace= AS3_StringN(as_class_path, (class_ptr - as_class_path)/sizeof(char));
    as_class = AS3_String(class_ptr+1);
  }
  else
  {
    as_namespace = AS3_String("");
    as_class = AS3_String(as_class_path);
  }
  AS3_Trace(as_namespace);
  AS3_Trace(as_class);
  
  AS3_Val ret = AS3_NSGet(as_namespace, as_class);

	AS3_Release(as_namespace);
	AS3_Release(as_class);

	return ret;
}

/* Create an ActionScript array from the lua stack values */
static AS3_Val create_as3_array_from_lua_stack(lua_State *L, int start, int end)
{
  char msg[1024];
  sprintf(msg, "create_as3_array_from_lua_stack() start %d %d", start, end);
  sztrace(msg);
  
  AS3_Val array = AS3_Array("");
  AS3_Val value;
  AS3LuaUserData *userdata;
  int i;
  for (i = start; i <= end; i++)
  {
    int t = lua_type(L, i);
    switch (t)
    {
      case LUA_TSTRING:  /* strings */
        value = AS3_String(lua_tostring(L, i));
        break;

      case LUA_TBOOLEAN:  /* booleans */
        value = lua_toboolean(L, i) ? AS3_True() : AS3_False();
        break;
      
      case LUA_TNUMBER:  /* numbers */
        value = AS3_Number(lua_tonumber(L, i));
        break;

      case LUA_TNIL:  /* nil */
        value = AS3_Null();
        break;

      case LUA_TUSERDATA:  /* userdata should only be AS3LuaUserData */
        userdata = (AS3LuaUserData *) lua_touserdata(L, i);
        value = userdata->value;
        break;
      
      case LUA_TLIGHTUSERDATA: /* not used */
      case LUA_TTABLE: /* TODO deal with this type */
      case LUA_TFUNCTION: /* TODO deal with this type */
      case LUA_TTHREAD: /* TODO deal with this type */
      default:  /* other values */
        value = AS3_String(lua_typename(L, t));
        break;
    }
    AS3_Trace(value);
    AS3_CallS("push", array, AS3_Array("AS3ValType", value));    
  }
  sztrace("create_as3_array_from_lua_stack() end");
  return array;
}

static void push_as3_lua_userdata(lua_State *L, AS3_Val val)
{
  AS3LuaUserData *userdata = (AS3LuaUserData *) lua_newuserdata(L, sizeof(AS3LuaUserData));
  userdata->value = val;
}

static void push_as3_to_lua_stack(lua_State *L, AS3_Val val)
{
  if (AS3_InstanceOf(val, Number_class))
  {
    lua_pushnumber(L, AS3_NumberValue(val));
  }
  else if (AS3_InstanceOf(val, int_class))
  {
    lua_pushnumber(L, AS3_IntValue(val));
  }
  else if (AS3_InstanceOf(val, String_class))
  {
    AS3_Malloced_Str str = AS3_StringValue(val);
    lua_pushstring(L, str);
    free(str);
  }
  else if (AS3_InstanceOf(val, Boolean_class))
  {
    AS3_Malloced_Str str = AS3_StringValue(val);
    lua_pushboolean(L, strcmp(str, "true") == 0);
    free(str);
  }
  else if (val == AS3_Undefined() || val == AS3_Null())
  {
    lua_pushnil(L);
  }
  else
  {
    push_as3_lua_userdata(L, val);
  }
}

static void clear_lua_stack(lua_State *L)
{
  int i;
  i = lua_gettop(L);
  for (i = lua_gettop(L); i > 0; i--)
    lua_remove(L, i);
}

static int as3_class(lua_State *L)
{
  sztrace("as3_class()");

  const char *classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package.ClassName' expected");
  
  AS3_Val as_class = get_class(classname);
  luaL_argcheck(L, as_class != NULL, 1, "'package.ClassName' must be valid");
  
  push_as3_lua_userdata(L, as_class);

  return 1;
}

static int as3_new(lua_State *L)
{
  sztrace("as3_new()");

  const char *classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package.ClassName' expected");
  
  AS3_Val as_class = get_class(classname);
  /* TODO error if as_class == null */
  
  sztrace("as3_new() params");
  AS3_Val params = create_as3_array_from_lua_stack(L, 2, lua_gettop(L));
  
  AS3_Val as_object = AS3_New(as_class, params);
  /* TODO error if as_object == null */

  push_as3_lua_userdata(L, as_object);
  
  AS3_Release(params);
  AS3_Release(as_class); /* TODO might want to store classes in a table to save loading again */
  return 1;
}

static int as3_release(lua_State *L)
{
  sztrace("as3_release()");

  AS3LuaUserData *userdata = (AS3LuaUserData *)lua_touserdata(L, 1);
  luaL_argcheck(L, userdata != NULL, 1, "'as3' expected");

  if (userdata->value != AS3_Null())
  {
    AS3_Release(userdata->value);
    userdata->value = AS3_Null();
  }
  
  return 0;
}

static int as3_get(lua_State *L)
{
  sztrace("as3_get()");

  AS3LuaUserData *userdata = (AS3LuaUserData *)lua_touserdata(L, 1);
  luaL_argcheck(L, userdata != NULL, 1, "'as3' expected");
  
  const char *property = lua_tostring(L, 2);
  luaL_argcheck(L, property != NULL, 2, "'property' expected");
  
  AS3_Val val = AS3_GetS(userdata->value, property);
  /* TODO check for invalid property */

  push_as3_to_lua_stack(L, val);
  
  return 1;
}

static int as3_set(lua_State *L)
{
  sztrace("as3_set()");

  AS3LuaUserData *userdata = (AS3LuaUserData *)lua_touserdata(L, 1);
  luaL_argcheck(L, userdata != NULL, 1, "'as3' expected");

  return 0;
}

static int as3_call(lua_State *L)
{
  sztrace("as3_call()");

  AS3LuaUserData *userdata = (AS3LuaUserData *)lua_touserdata(L, 1);
  luaL_argcheck(L, userdata != NULL, 1, "'as3' expected");

  return 0;
}

static int as3_yield(lua_State *L)
{
  sztrace("as3_new()");
  return 0;
}

static int as3_stage(lua_State *L)
{
  sztrace("as3_stage()");
  return 0;
}

static const luaL_reg AS3_LUA_LIB[] =
{
  { "class", as3_class },
  { "new", as3_new },
  { "release", as3_release },
  { "get", as3_get },
  { "set", as3_set },
  { "call", as3_call },
  { "yield", as3_yield },
  { "stage", as3_stage },
  { NULL, NULL } /* The end */
};

/* 
  Creates the lua context, opens the standard libs, and registers functions
*/
static lua_State * create_context()
{
  lua_State *lua_ctx;
	lua_ctx = lua_open();
  luaL_openlibs(lua_ctx);
  luaL_register(lua_ctx, "as3", AS3_LUA_LIB);
  clear_lua_stack(lua_ctx); /* TODO the call above put something on the stack */
  return lua_ctx;
}

/* This function will be called at the top of the generated main(). The GGINIT_DEFINED macro is required. */
#define GGINIT_DEFINED true
static void ggInit()
{
	sztrace("setting up lua_wrapper library");

	/* setup some useful constants */
	no_params = AS3_Array("");
	zero_param = AS3_Int(0);
  Number_class = get_class("Number");
  int_class = get_class("int");
  String_class = get_class("String");
  Boolean_class = get_class("Boolean");
}


/* end of passthru C section */
}

public function luaCreateContext():(lua_State *)uint
{
  return create_context();
}

public function luaClose(lua_ctx:(lua_State *)uint):void
{
  lua_close(lua_ctx);
}

public function luaDoString(lua_ctx:(lua_State *)uint, str:String):(AS3_Val)Array
{
  int status;
  status = luaL_dostring(lua_ctx, str);
  /* TODO handle status */
  return create_as3_array_from_lua_stack(lua_ctx, 1, lua_gettop(lua_ctx));
}
