{ /* start of pass-thru C section */
/*
** This is the generated file produced from lua_wrapper.gg
** Wrapper for Lua.
**
*/

#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>

/* Include the Lua API header files. */
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

/* AS3.h is included automatically by gluegen */

void sztrace(char*);

/* Some global variables initialized in ggInit() */
AS3_Val no_params = NULL;
AS3_Val zero_param = NULL;
AS3_Val Number_class = NULL;
AS3_Val int_class = NULL;
AS3_Val String_class = NULL;
AS3_Val Boolean_class = NULL;

typedef struct AS3LuaUserData
{
  AS3_Val value;
} AS3LuaUserData;

#define checkas3(L) \
  (AS3LuaUserData*)luaL_checkudata(L, 1, "LuaAlchemy.as3")

/************************************************************
* Helper Functions
************************************************************/

/* Helper function get an actionscript class with the given namespace and class name */
static AS3_Val get_class(const char *as_class_path)
{
  AS3_Val as_namespace;
  AS3_Val as_class;
  char *class_ptr;

  /* TODO might want to store classes in a table to save loading again */

  class_ptr = strrchr(as_class_path, '.');
  
  if (class_ptr > as_class_path)
  {
    as_namespace = AS3_StringN(as_class_path, (class_ptr - as_class_path)/sizeof(char));
    as_class = AS3_String(class_ptr+1);
  }
  else
  {
    as_namespace = AS3_String("");
    as_class = AS3_String(as_class_path);
  }
  
  AS3_Val ret = AS3_NSGet(as_namespace, as_class);
  
  /* TODO check for failure getting class */

	AS3_Release(as_namespace);
	AS3_Release(as_class);

	return ret;
}

static AS3_Val get_as3_value_from_lua_stack(lua_State *L, int i)
{
  AS3_Val value;
  AS3LuaUserData *userdata;
  int t;

  value = AS3_Undefined();
  t = lua_type(L, i);

  switch (t)
  {
    case LUA_TSTRING:  /* strings */
      value = AS3_String(lua_tostring(L, i));
      break;

    case LUA_TBOOLEAN:  /* booleans */
      value = lua_toboolean(L, i) ? AS3_True() : AS3_False();
      break;
  
    case LUA_TNUMBER:  /* numbers */
      value = AS3_Number(lua_tonumber(L, i));
      break;

    case LUA_TNIL:  /* nil */
      value = AS3_Null();
      break;

    case LUA_TUSERDATA:  /* userdata should only be AS3LuaUserData */
      userdata = (AS3LuaUserData *) lua_touserdata(L, i);
      value = userdata->value;
      break;
  
    case LUA_TLIGHTUSERDATA: /* not used */
    case LUA_TTABLE: /* TODO deal with this type */
    case LUA_TFUNCTION: /* TODO deal with this type */
    case LUA_TTHREAD: /* TODO deal with this type */
    default:  /* other values */
      value = AS3_String(lua_typename(L, t));
      break;
  }
  
  return value;
}

/* Create an ActionScript array from the lua stack values */
static AS3_Val create_as3_array_from_lua_stack(lua_State *L, int start, int end)
{
  AS3_Val array;
  AS3_Val value;
  int i;
  
  array = AS3_Array("");

  for (i = start; i <= end; i++)
  {
    value = get_as3_value_from_lua_stack(L, i);
    AS3_CallS("push", array, AS3_Array("AS3ValType", value));    
  }

  return array;
}

static void push_as3_lua_userdata(lua_State *L, AS3_Val val)
{
  AS3LuaUserData *userdata;

  userdata = (AS3LuaUserData *) lua_newuserdata(L, sizeof(AS3LuaUserData));
  userdata->value = val;

  luaL_getmetatable(L, "LuaAlchemy.as3");
  lua_setmetatable(L, -2);
}

static void push_as3_to_lua_stack(lua_State *L, AS3_Val val)
{
  AS3_Malloced_Str str;
  
  if (AS3_InstanceOf(val, Number_class))
  {
    lua_pushnumber(L, AS3_NumberValue(val));
  }
  else if (AS3_InstanceOf(val, int_class))
  {
    lua_pushnumber(L, AS3_IntValue(val));
  }
  else if (AS3_InstanceOf(val, String_class))
  {
    str = AS3_StringValue(val);
    lua_pushstring(L, str);
    free(str);
  }
  else if (AS3_InstanceOf(val, Boolean_class))
  {
    lua_pushboolean(L, AS3_IntValue(val));
  }
  else if (val == AS3_Undefined() || val == AS3_Null())
  {
    lua_pushnil(L);
  }
  else
  {
    push_as3_lua_userdata(L, val);
  }
}

/************************************************************
* AS3 functions exported to Lua
************************************************************/

static int as3_yield(lua_State *L)
{
  flyield();
  return 0;
}

static int as3_stage(lua_State *L)
{
  sztrace("as3_stage()");
  /* TODO the stage isn't crossing the C/Lua or Alchemy bindings intact */
  push_as3_to_lua_stack(L, AS3_Stage());
  return 1;
}

static int as3_class(lua_State *L)
{
  const char *classname;
  AS3_Val as_class;
  
  classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package.ClassName' expected");
  
  as_class = get_class(classname);
  luaL_argcheck(L, as_class != NULL, 1, "'package.ClassName' must be valid");
  
  /* TODO check if get_class failed */
  
  push_as3_lua_userdata(L, as_class);

  return 1;
}

static int as3_new(lua_State *L)
{
  const char *classname;
  AS3_Val as_class;
  AS3_Val params;
  AS3_Val as_object;
  
  classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package.ClassName' expected");
  
  as_class = get_class(classname);
  /* TODO error if as_class == null */
  
  params = create_as3_array_from_lua_stack(L, 2, lua_gettop(L));
  
  as_object = AS3_New(as_class, params);
  /* TODO error if as_object == null, make sure you free the class and params */

  push_as3_lua_userdata(L, as_object);
  
  AS3_Release(params);
  AS3_Release(as_class); /* TODO might want to store classes in a table to save loading again */
  return 1;
}

static int as3_release(lua_State *L)
{
  AS3LuaUserData *userdata;

  userdata = checkas3(L);
  if (userdata->value != AS3_Null())
  {
    AS3_Release(userdata->value);
    userdata->value = AS3_Null();
  }
  
  return 0;
}

static int as3_toluatype(lua_State *L)
{
  AS3LuaUserData *userdata;

  userdata = checkas3(L);
  push_as3_to_lua_stack(L, userdata->value);
  
  return 1;
}

static int as3_get(lua_State *L)
{
  AS3LuaUserData *userdata;
  const char *property;
  AS3_Val val;
  
  userdata = checkas3(L);
  
  property = lua_tostring(L, 2);
  luaL_argcheck(L, property != NULL, 2, "'property' expected");
  
  val = AS3_GetS(userdata->value, property);
  /* TODO check for AS3_GetS successful */

  push_as3_to_lua_stack(L, val);
  
  return 1;
}

static int as3_set(lua_State *L)
{
  AS3LuaUserData *userdata;
  const char *property;
  AS3_Val value;
  
  userdata = checkas3(L);
  
  property = lua_tostring(L, 2);
  luaL_argcheck(L, property != NULL, 2, "'property' expected");
  
  value = get_as3_value_from_lua_stack(L, 3);
  luaL_argcheck(L, value != AS3_Undefined(), 3, "'value' expected");
   
  AS3_SetS(userdata->value, property, value);
  /* TODO check if AS3_SetS sucessful */

  return 0;
}

static int as3_assign(lua_State *L)
{
  AS3LuaUserData *userdata;
  AS3_Val value;
  
  userdata = checkas3(L);
  
  value = get_as3_value_from_lua_stack(L, 2);
  luaL_argcheck(L, value != AS3_Undefined(), 2, "'value' expected");
   
  /* TODO how to assign the value of a String, Number, int, etc? var s:String; s = "hello"; and do we care? */

  return 0;
}

static int as3_call(lua_State *L)
{
  AS3LuaUserData *userdata;
  AS3_Val params;
  const char *function_name;
  AS3_Val result;
  
  userdata = checkas3(L);

  function_name = lua_tostring(L, 2);
  luaL_argcheck(L, function_name != NULL, 2, "'function_name' expected");

  params = create_as3_array_from_lua_stack(L, 3, lua_gettop(L));

  result = AS3_CallS(function_name, userdata->value, params);
  /* TODO check for function call failure, make sure to relase params */
  
  AS3_Release(params);
  
  push_as3_to_lua_stack(L, result);

  return 1;
}

static int as3_type(lua_State *L)
{
  AS3LuaUserData *userdata;
  AS3_Val value;
  
  userdata = checkas3(L);
  
  /* TODO return string name of type of given as3.new() result (see type(), io.type()) */

  return 0;
}

static int as3_classname(lua_State *L)
{
  AS3LuaUserData *userdata;
  AS3_Val value;
  
  userdata = checkas3(L);
  
  /* TODO Also we probably would need some as3.classname() to distinguish between classes. */

  return 0;
}

static const luaL_reg AS3_LUA_LIB[] =
{
  { "yield", as3_yield },
  { "stage", as3_stage },
  { "class", as3_class },
  { "new", as3_new },
  { "release", as3_release },
  { "toluatype", as3_toluatype },
  { "get", as3_get },
  { "set", as3_set },
  { "assign", as3_assign },
  { "call", as3_call },
  { "type", as3_type },
  { "classname", as3_classname },
  { NULL, NULL } /* The end */
};

/* 
  Creates the lua_state, opens the standard libs, and registers functions
*/
static lua_State * lua_initialize_state()
{
  lua_State *L;
	L = lua_open();
  luaL_openlibs(L);

  luaL_newmetatable(L, "LuaAlchemy.as3");
  lua_pop(L, 1); /* pop as3 metatable created by above call */

  luaL_register(L, "as3", AS3_LUA_LIB);
  lua_pop(L, 1); /* pop as3 library table created by above call */
  
  return L;
}

/* This function will be called at the top of the generated main(). The GGINIT_DEFINED macro is required. */
#define GGINIT_DEFINED true
static void ggInit()
{
	/* setup some useful constants */
	no_params = AS3_Array("");
	zero_param = AS3_Int(0);
  Number_class = get_class("Number");
  int_class = get_class("int");
  String_class = get_class("String");
  Boolean_class = get_class("Boolean");
}


/* end of passthru C section */
}

public function luaInitilizeState():(lua_State *)uint
{
  return lua_initialize_state();
}

public function luaClose(luaState:(lua_State *)uint):void
{
  lua_close(luaState);
}

public function luaDoString(luaState:(lua_State *)uint, str:String):(AS3_Val)Array
{
  int status;
  status = luaL_dostring(luaState, str);
  /* TODO handle status */
  return create_as3_array_from_lua_stack(luaState, 1, lua_gettop(luaState));
}
