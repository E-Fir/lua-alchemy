{ /* start of pass-thru C section */
/*
** This is the generated file produced from lua_wrapper.gg
** Wrapper for Lua.
**
*/

#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>

/* Include the Lua API header files. */
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#include "lstack.h"

/* AS3.h is included automatically by gluegen */

void sztrace(char *);

/* Some global variables initialized in ggInit() */
AS3_Val no_params = NULL;
AS3_Val zero_param = NULL;
AS3_Val Number_class = NULL;
AS3_Val int_class = NULL;
AS3_Val String_class = NULL;
AS3_Val Boolean_class = NULL;
AS3_Val flash_utils_namespace = NULL;
AS3_Val getQualifiedClassName_method = NULL;
AS3_Val Array_class = NULL;

typedef struct AS3LuaUserData
{
  AS3_Val value;
} AS3LuaUserData;

typedef struct LuaFunctionCallbackData
{
  lua_State * L;
  int ref;
  AS3_Val as3Function;
} LuaFunctionCallbackData;

#define AS3LUA_METATABLE "LuaAlchemy.as3"
#define AS3LUA_CALLBACKMT "LuaAlchemy.cbMT"
#define AS3LUA_CALLBACKS "LuaAlchemy.callbacks"

typedef unsigned char BOOL;
#define TRUE (1)
#define FALSE (0)

#define AS3LUA_CBFNINDEX (1)
#define AS3LUA_CBSDATAINDEX (2)

#define check_as3userdata(L, index) \
  (AS3LuaUserData *)luaL_checkudata(L, index, AS3LUA_METATABLE)

/* Uncomment this to get a lot of debug traces */
/*
#define DO_SPAM 1
*/

#ifdef DO_SPAM
  #define SPAM(a) sztrace a
#else
  #define SPAM(a) (void)0
#endif /* DO_SPAM */

/* TODO: Use some better Alchemy API */
void fatal_error(const char * msg)
{
  sztrace("Lua Alchemy fatal error");
  sztrace((char *)msg);
  exit(-1);
}

/* Two arguments version to avoid string concatenation */
void fatal_error2(const char * msg1, const char * msg2)
{
  sztrace("Lua Alchemy fatal error");
  sztrace((char *)msg1);
  sztrace((char *)msg2);
  exit(-1);
}

/************************************************************
* AS3.h Helper Functions
************************************************************/

/*
* Get an actionscript class with the given namespace and class name
* in the format: package::ClassName
*/
static AS3_Val get_class(const char * as_class_path)
{
  AS3_Val as_namespace;
  AS3_Val as_class;
  char * class_ptr = NULL;

  /* TODO might want to store classes in a table to save loading again */

  class_ptr = strstr(as_class_path, "::");

  if (class_ptr > as_class_path)
  {
    as_namespace = AS3_StringN(as_class_path, (class_ptr - as_class_path) / sizeof(char));
    as_class = AS3_String(class_ptr + 2);
  }
  else
  {
    as_namespace = AS3_Undefined();
    as_class = AS3_String(as_class_path);
  }

  AS3_Val ret = AS3_NSGet(as_namespace, as_class);

  /* TODO check for failure getting class */

  AS3_Release(as_namespace);
  AS3_Release(as_class);

  return ret;
}

/*
  TODO: Ugly workaround. Remove.
        See http://tinyurl.com/a9djb2
*/
static BOOL is_null(AS3_Val val)
{
  BOOL result = FALSE;
  AS3_Val argsVal = AS3_Array("AS3ValType", val);
  AS3_Val classNameVal = AS3_Call(getQualifiedClassName_method, NULL, argsVal);
  AS3_Malloced_Str className = AS3_StringValue(classNameVal);
  AS3_Release(argsVal);
  AS3_Release(classNameVal);

  result = (strncmp(className, "null", 4) == 0);

  free(className);

  return result;
}

/************************************************************
* Lua Helper Functions
************************************************************/

int panic_handler(lua_State * L)
{
  const char * pStr = lua_tostring(L, -1);
  if (pStr != NULL)
  {
    /*
      NOTE: Not doing pop, since we would exit program anyway,
            and Lua interpreter 'L' is in 'undefined state'.
      lua_pop(L, 1);
    */

    fatal_error2("Lua panicked:", (char *)pStr);
  }

  fatal_error("Lua panicked, failed to get error message.");

  return 1; /* Unreachable */
}

/*
 * BEGIN COPY-PASTE FROM Lua 5.1.4 ldblib.c
 */

static lua_State *getthread (lua_State * L, int *arg) {
  if (lua_isthread(L, 1)) {
    *arg = 1;
    return lua_tothread(L, 1);
  }
  else {
    *arg = 0;
    return L;
  }
}

#define LEVELS1 12  /* size of the first part of the stack */
#define LEVELS2 10  /* size of the second part of the stack */

static int db_errorfb (lua_State * L) {
  int level;
  int firstpart = 1;  /* still before eventual `...' */
  int arg;
  lua_State * L1 = getthread(L, &arg);
  lua_Debug ar;
  if (lua_isnumber(L, arg+2)) {
    level = (int)lua_tointeger(L, arg+2);
    lua_pop(L, 1);
  }
  else
    level = (L == L1) ? 1 : 0;  /* level 0 may be this own function */
  if (lua_gettop(L) == arg)
    lua_pushliteral(L, "");
  else if (!lua_isstring(L, arg+1)) return 1;  /* message is not a string */
  else lua_pushliteral(L, "\n");
  lua_pushliteral(L, "stack traceback:");
  while (lua_getstack(L1, level++, &ar)) {
    if (level > LEVELS1 && firstpart) {
      /* no more than `LEVELS2' more levels? */
      if (!lua_getstack(L1, level+LEVELS2, &ar))
        level--;  /* keep going */
      else {
        lua_pushliteral(L, "\n\t...");  /* too many levels */
        while (lua_getstack(L1, level+LEVELS2, &ar))  /* find last levels */
          level++;
      }
      firstpart = 0;
      continue;
    }
    lua_pushliteral(L, "\n\t");
    lua_getinfo(L1, "Snl", &ar);
    lua_pushfstring(L, "%s:", ar.short_src);
    if (ar.currentline > 0)
      lua_pushfstring(L, "%d:", ar.currentline);
    if (*ar.namewhat != '\0')  /* is there a name? */
        lua_pushfstring(L, " in function " LUA_QS, ar.name);
    else {
      if (*ar.what == 'm')  /* main? */
        lua_pushfstring(L, " in main chunk");
      else if (*ar.what == 'C' || *ar.what == 't')
        lua_pushliteral(L, " ?");  /* C function or tail call */
      else
        lua_pushfstring(L, " in function <%s:%d>",
                           ar.short_src, ar.linedefined);
    }
    lua_concat(L, lua_gettop(L) - arg);
  }
  lua_concat(L, lua_gettop(L) - arg);
  return 1;
}

/*
 * END COPY-PASTE FROM Lua 5.1.4 ldblib.c
 */

#undef LEVELS1
#undef LEVELS2

/*
 * BEGIN COPY-PASTE FROM Lua 5.1.4 lbaselib.c
 */

static int luaB_tostring (lua_State *L) {
  luaL_checkany(L, 1);
  if (luaL_callmeta(L, 1, "__tostring"))  /* is there a metafield? */
    return 1;  /* use its value */
  switch (lua_type(L, 1)) {
    case LUA_TNUMBER:
      lua_pushstring(L, lua_tostring(L, 1));
      break;
    case LUA_TSTRING:
      lua_pushvalue(L, 1);
      break;
    case LUA_TBOOLEAN:
      lua_pushstring(L, (lua_toboolean(L, 1) ? "true" : "false"));
      break;
    case LUA_TNIL:
      lua_pushliteral(L, "nil");
      break;
    default:
      lua_pushfstring(L, "%s: %p", luaL_typename(L, 1), lua_topointer(L, 1));
      break;
  }
  return 1;
}

/*
 * END COPY-PASTE FROM Lua 5.1.4 lbaselib.c
 */

static int do_pcall_with_traceback(lua_State * L, int narg, int nresults)
{
  /* WARNING: Panic alert! Use L*_FN checkers here! */

  SPAM(("do_pcall_with_traceback(): begin"));

  LCALL_ARGS(L, stack, 1 + narg); /* The function itself with arguments */
  int status = 0;

  lua_pushcfunction(L, db_errorfb);  /* push traceback function */
  lua_insert(L, LBASE(L, stack));  /* put it under chunk and args */

  LCHECK_FN(L, stack, 1 + narg + 1, fatal_error);

  SPAM(("do_pcall_with_traceback(): before call"));

  status = lua_pcall(L, narg, nresults, LBASE(L, stack));

  lua_remove(L, LBASE(L, stack));  /* remove traceback function */

  if (status != 0)
  {
    SPAM(("do_pcall_with_traceback(): after call ERROR"));

    /* force a complete garbage collection in case of errors */
    lua_gc(L, LUA_GCCOLLECT, 0);

    LCHECK_FN(L, stack, 1, fatal_error);
  }
  else
  {
    SPAM(("do_pcall_with_traceback(): after call OK"));

    if (nresults != LUA_MULTRET)
    {
      LCHECK_FN(L, stack, nresults, fatal_error);
    }
  }

  SPAM(("do_pcall_with_traceback(): end"));

  return status;
}

static AS3_Val as3_lua_callback(void * data, AS3_Val args);
static AS3_Val create_as3_value_from_lua_stack(
    lua_State * L,
    int start,
    int end,
    BOOL collapse_array
  );
static int push_as3_lua_userdata(lua_State * L, AS3_Val val);
static int push_as3_to_lua_stack(lua_State * L, AS3_Val val);

static int push_as3_array_to_lua_stack(lua_State * L, AS3_Val array)
{
  LCALL(L, stack);

  int len = 0;
  int i = 0;
  AS3_Val cur;

  if (!AS3_InstanceOf(array, Array_class))
  {
    LRETURN(L, stack, 0);
  }

  len = AS3_IntValue(AS3_GetS(array, "length"));
  for (i = 0; i < len; i++)
  {
    cur = AS3_Get(array, AS3_Int(i));
    push_as3_to_lua_stack(L, cur);
    AS3_Release(cur);
  }

  LRETURN(L, stack, len);
}

static int as3_trace(lua_State * L);

/*
* Function used as a callback for all Lua functions passed through
* get_as3_value_from_lua_stack()
*/
static AS3_Val as3_lua_callback(void * data, AS3_Val args)
{
  /* WARNING: Panic alert! Use L*_FN checkers here! */

  SPAM(("as3_lua_callback(): begin"));

  AS3_Val res;
  LuaFunctionCallbackData * func_data = (LuaFunctionCallbackData *) data;
  int nargs = 0;
  int status = 0;
  int results_base = 0;
  lua_State * L = func_data->L;
  if (L == NULL)
  {
    /* TODO: Should we crash here?
    fatal_error("state expired"); / * Does not return * /
    */
    sztrace("as3_lua_callback: state expired");
    return AS3_Undefined();
  }

  { /* A new scope for LCALL to work (C89 conformance) */
    LCALL(L, stack);

    /* TODO: Cache that with lua_ref, it is faster */
    lua_getfield(L, LUA_REGISTRYINDEX, AS3LUA_CALLBACKS);

    /* TODO: Assert we have a table here */

    lua_rawgeti(L, -1, func_data->ref); /* push stored function */

    if (lua_istable(L, -1) == 0) /* Probably nil */
    {
      lua_pop(L, 1); /* Pop bad callback table */
      LCHECK_FN(L, stack, 0, fatal_error);

      fatal_error("function callback not found"); /* Does not return */
    }

    lua_rawgeti(L, -1, AS3LUA_CBFNINDEX);

    /* TODO: Assert we have Lua function (or other callable object) on the top of the stack */

    LCHECK_FN(L, stack, 2 + 1, fatal_error);

    nargs = push_as3_array_to_lua_stack(L, args); /* push arguments */

    LCHECK_FN(L, stack, 2 + 1 + nargs, fatal_error);

    results_base = LBASE(L, stack) + 2;
    status = do_pcall_with_traceback(L, nargs, LUA_MULTRET);
    if (status != 0)
    {
      const char * msg = NULL;

      LCHECK_FN(L, stack, 2 + 1, fatal_error); /* Tables and error message */
      lua_remove(L, -2); /* Remove AS3LUA_CALLBACKS table */
      lua_remove(L, -2); /* Remove holder table */
      LCHECK_FN(L, stack, 1, fatal_error); /* Only error message */

      /* Error message is on stack */
      /* NOTE: It is not necessary string! If we want to preserve its type, see lua_DoString. */

      if (lua_tostring(L, -1) == NULL)
      {
        lua_pop(L, 1);
        lua_pushliteral(L, "(non-string)");
      }

      LCHECK_FN(L, stack, 1, fatal_error);

      lua_pushliteral(L, "Error in Lua callback:\n");
      lua_insert(L, -2);

      LCHECK_FN(L, stack, 2, fatal_error);

      lua_concat(L, 2);

      LCHECK_FN(L, stack, 1, fatal_error);

      sztrace((char *)lua_tostring(L, -1));

      /* TODO: ?! */
      /* lua_error(L); */

      msg = lua_tostring(L, -1);
      lua_pop(L, 1);

/*
      fatal_error(msg); / * Does not return * /
*/
    }

    /* Process results */

#ifdef DO_SPAM
    /* TODO: Remove */
    lua_pushcfunction(L, as3_trace);
    lua_pushliteral(L, "STACK");
    Pdumpstack(L, results_base);
    lua_call(L, 2, 0);
#endif /* DO_SPAM */

    res = create_as3_value_from_lua_stack(L, results_base + 1, LTOP(L, stack), TRUE);

#ifdef DO_SPAM
    SPAM(("as3_lua_callback() result type"));
    AS3_Trace(AS3_Call(getQualifiedClassName_method, NULL, AS3_Array("AS3ValType", res)));
#endif /* DO_SPAM */

    lua_settop(L, LBASE(L, stack)); /* Cleanup results and two holder tables */

    SPAM(("as3_lua_callback(): end"));

    return res;
  }

  /* Unreachable */
}

static int release_callback(lua_State * L)
{
  SPAM(("release_callback() : begin"));

  LuaFunctionCallbackData ** pUserdata = (LuaFunctionCallbackData **)luaL_checkudata(
      L, 1, AS3LUA_CALLBACKMT
    );
  if (pUserdata == NULL)
  {
    SPAM(("release_callback() : bad userdata"));
    return 0;
  }

  LuaFunctionCallbackData * pCallback = *pUserdata;
  if (pCallback == NULL)
  {
    SPAM(("release_callback() : bad callback"));
    return 0;
  }

  if (pCallback->L != NULL)
  {
    if (pCallback->as3Function != AS3_Undefined())
    {
      SPAM(("release_callback() : before release"));
      AS3_Release(pCallback->as3Function);
      SPAM(("release_callback() : after release"));
      pCallback->as3Function = AS3_Undefined();
    }

    pCallback->L = NULL;
  }

  *pUserdata = NULL;

  SPAM(("release_callback() : end"));

  return 0;
}

static AS3_Val setup_callback(lua_State * L, int index)
{
  LCALL(L, stack);

  SPAM(("setup_callback() : begin"));

  AS3_Val as3Function;
  int ref = 0;
  LuaFunctionCallbackData ** pUserdata = NULL;

  /*
    NOTE: Can't do lua_newuserdata() immediately
          since it would be deleted by Lua on lua_close()
  */
  /* TODO: Free this somewhere! When freeing, remove pData->ref from the state */
  LuaFunctionCallbackData * pData = malloc(sizeof(LuaFunctionCallbackData));

  index = LABSIDX(L, stack, index); /* Normalize index */

  /* TODO: Cache that with lua_ref, it is faster */
  lua_getfield(L, LUA_REGISTRYINDEX, AS3LUA_CALLBACKS);
  /* TODO: Assert this is a table */

  lua_newtable(L);

  LCHECK(L, stack, 2);

  lua_pushvalue(L, index); /* Store function */
  lua_rawseti(L, -2, AS3LUA_CBFNINDEX);

  LCHECK(L, stack, 2);

  pUserdata = lua_newuserdata(L, sizeof(LuaFunctionCallbackData *));
  *pUserdata = pData;

  luaL_getmetatable(L, AS3LUA_CALLBACKMT);
  lua_setmetatable(L, -2);
  lua_rawseti(L, -2, AS3LUA_CBSDATAINDEX);

  LCHECK(L, stack, 2);

  ref = luaL_ref(L, -2);

  LCHECK(L, stack, 1);

  lua_pop(L, 1); /* Pop AS3LUA_CALLBACKS */

  as3Function = AS3_Function(pData, as3_lua_callback);

  pData->ref = ref;
  pData->L = L;
  pData->as3Function = as3Function;

  LCHECK(L, stack, 0);

  SPAM(("setup_callback() : end"));

  return as3Function;
}

/*
* Take the Lua stack item at index i and convert it into an
* ActionScript value.
*/
static AS3_Val get_as3_value_from_lua_stack(lua_State * L, int i)
{
  /* WARNING: Panic alert! Use L*_FN checkers here! */

  LCALL(L, stack);
  AS3_Val value;

  int t = lua_type(L, i);
  switch (t)
  {
    case LUA_TSTRING:  /* strings */
    {
      size_t length = 0;
      const char * str = lua_tolstring(L, i, &length);
      if (str == NULL)  /* NOTE: This is unreachable. Assert instead */
      {
        length = 6;
        str = "(null)";
      }
      /* NOTE: Alchemy .5a truncates embedded zeroes in string regardless to the passed length */
      value = AS3_StringN(str, length);
    }
      break;

    case LUA_TBOOLEAN:  /* booleans */
      value = lua_toboolean(L, i) ? AS3_True() : AS3_False();
      break;

    case LUA_TNUMBER:  /* numbers */
      value = AS3_Number(lua_tonumber(L, i));
      break;

    case LUA_TNIL:  /* nil */
      value = AS3_Null();
      break;

    case LUA_TUSERDATA:  /* userdata */
      {
        void * userdata = lua_touserdata(L, i);
        lua_getfield(L, LUA_REGISTRYINDEX, AS3LUA_METATABLE);
        if (userdata == NULL || !lua_getmetatable(L, i))
        {
          lua_pop(L, 1); /* Pop AS3LUA_METATABLE */
          value = AS3_String(lua_typename(L, t));
        }
        else if (!lua_rawequal(L, -2, -1))
        {
          lua_pop(L, 2); /* Pop AS3LUA_METATABLE and userdata metatable */
          value = AS3_String(lua_typename(L, t));
        }
        else
        {
          lua_pop(L, 2); /* Pop AS3LUA_METATABLE and userdata metatable */
          AS3LuaUserData * userdata = (AS3LuaUserData *)lua_touserdata(L, i);
      value = userdata->value;
        }
      }
      break;

    case LUA_TFUNCTION: /* function */
      value = setup_callback(L, i);
      break;

    case LUA_TLIGHTUSERDATA: /* TODO: blackbox this type */
    case LUA_TTABLE: /* TODO: deal with this type */
    case LUA_TTHREAD: /* TODO: blackbox this type */
      value = AS3_String(lua_typename(L, t));
      break;

    default:  /* unreachable */
      fatal_error("unknown Lua type");
      break;
  }

#ifdef DO_SPAM
  SPAM(("get_as3_value_from_lua_stack(): end"));
  AS3_Trace(AS3_Call(getQualifiedClassName_method, NULL, AS3_Array("AS3ValType", value)));
#endif /* DO_SPAM */

  LCHECK_FN(L, stack, 0, fatal_error);

  return value;
}

/*
* Create an ActionScript value from the lua stack starting
* at index start and ending at index end.  If collapse_array == 1,
* an empty return will be transformed into AS3_Undefined() and a
* return of length 1 will just return the specific value.
* Otherwise an array is returned.
*/
static AS3_Val create_as3_value_from_lua_stack(
    lua_State * L,
    int start,
    int end,
    BOOL collapse_array
  )
{
  /* WARNING: Panic alert! Use L*_FN checkers here! */

  LCALL(L, stack);
  AS3_Val ret;
  AS3_Val value;

  SPAM(("create_as3_value_from_lua_stack(): begin"));

  if (collapse_array == TRUE && start > end)
  {
    ret = AS3_Null();
  }
  else if (collapse_array == TRUE && start == end)
  {
    ret = get_as3_value_from_lua_stack(L, start);
  }
  else
  {
    int i;

    ret = AS3_Array("");
    for (i = start; i <= end; ++i)
    {
      SPAM(("create_as3_value_from_lua_stack() + 1 begin"));
      value = get_as3_value_from_lua_stack(L, i);
      AS3_CallS("push", ret, AS3_Array("AS3ValType", value));
      SPAM(("create_as3_value_from_lua_stack() + 1 end"));
    }
  }

#ifdef DO_SPAM
  SPAM(("create_as3_value_from_lua_stack(): end"));
  AS3_Trace(AS3_Call(getQualifiedClassName_method, NULL, AS3_Array("AS3ValType", ret)));
#endif /* DO_SPAM */

  LCHECK_FN(L, stack, 0, fatal_error);

  return ret;
}

/*
* Take the given ActionScript value and push it onto the
* stack with the correct metatable.
*/
static int push_as3_lua_userdata(lua_State * L, AS3_Val val)
{
  LCALL(L, stack);

  AS3LuaUserData * userdata = NULL;

  AS3_Acquire(val);

  userdata = (AS3LuaUserData *)lua_newuserdata(L, sizeof(AS3LuaUserData));
  userdata->value = val;

  luaL_getmetatable(L, AS3LUA_METATABLE);
  lua_setmetatable(L, -2);

  LRETURN(L, stack, 1);
}

/*
* Given an ActionScript object, push it onto the Lua stack as a Lua native
* type if a primitive class (String, Number, Boolean, int, null)
* or push as userdata
*/
static int push_as3_to_lua_stack(lua_State * L, AS3_Val val)
{
  LCALL(L, stack);

#ifdef DO_SPAM
  SPAM(("push_as3_to_lua_stack(): begin: value, type"));
  AS3_Trace(val);
  AS3_Trace(AS3_Call(getQualifiedClassName_method, NULL, AS3_Array("AS3ValType", val)));
#endif /* DO_SPAM */

  if (AS3_InstanceOf(val, Number_class))
  {
    lua_pushnumber(L, AS3_NumberValue(val));
  }
  else if (AS3_InstanceOf(val, int_class))
  {
    lua_pushinteger(L, AS3_IntValue(val));
  }
  else if (AS3_InstanceOf(val, String_class))
  {
    /* TODO: Release?! */
    AS3_Val lengthVal = AS3_GetS(val, "length");
    size_t length = AS3_IntValue(lengthVal);
    AS3_Malloced_Str str = AS3_StringValue(val);

    lua_pushlstring(L, str, length);
    free(str);
  }
  else if (AS3_InstanceOf(val, Boolean_class))
  {
    lua_pushboolean(L, AS3_IntValue(val));
  }
  else if (val == AS3_Undefined())
  {
    lua_pushnil(L);
  }
  else if (is_null(val))
  {
    lua_pushnil(L);
  }
  else
  {
    SPAM(("push_as3_to_lua_stack(): defaulting to userdata"));
    push_as3_lua_userdata(L, val);
  }

  SPAM(("push_as3_to_lua_stack(): end"));

  LRETURN(L, stack, 1);
}

/************************************************************
* AS3 functions exported to Lua
************************************************************/

/*
* Release control to Flash and return to this point on the next timer tick
* Lua example: as3.yield()
*/
static int as3_yield(lua_State * L)
{
  LCALL(L, stack);

  flyield();

  LRETURN(L, stack, 0);
}

/*
* Return the Flash stage
* Lua example: as3.stage()
*/
static int as3_stage(lua_State * L)
{
  LCALL(L, stack);

  /* TODO: This is currently void, call setSprite() before init() to fix */
  push_as3_lua_userdata(L, AS3_Stage());

  LRETURN(L, stack, 1);
}

/*
* Return the requested class in package::ClassName form.
* Can be used to call static class functions
* Lua example: v = as3.class("flash.utils.ByteArray")
*/
static int as3_class(lua_State * L)
{
  LCALL(L, stack);

  const char * classname = NULL;
  AS3_Val as_class;

  classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package::ClassName' expected");

  as_class = get_class(classname);
  luaL_argcheck(L, as_class != NULL, 1, "'package::ClassName' must be valid");

  /* TODO check if get_class failed */

  push_as3_lua_userdata(L, as_class);

  AS3_Release(as_class);

  LRETURN(L, stack, 1);
}

/*
* Create a new instance of the given class in package::ClassName form.
* Lua example: v = as3.new("flash.utils.ByteArray")
*/
static int as3_new(lua_State * L)
{
  LCALL(L, stack);

  const char * classname = NULL;
  AS3_Val as_class;
  AS3_Val params;
  AS3_Val as_object;

  classname = lua_tostring(L, 1);
  luaL_argcheck(L, classname != NULL, 1, "'package::ClassName' expected");

  as_class = get_class(classname);
  /* TODO error if as_class == null */

  params = create_as3_value_from_lua_stack(L, 2, LTOP(L, stack), FALSE);

  as_object = AS3_New(as_class, params);
  /* TODO error if as_object == null, make sure you free the class and params */

  push_as3_lua_userdata(L, as_object);

  AS3_Release(as_object);
  AS3_Release(params);
  AS3_Release(as_class); /* TODO might want to store classes in a table to save loading again */

  LRETURN(L, stack, 1);
}

/*
* Release the given ActionScript object so Flash will do garbage collection.
* Lua example: as3.release(v)
*/
static int as3_release(lua_State * L)
{
  SPAM(("as3_release() : begin"));

  LCALL(L, stack);

  AS3LuaUserData * userdata = check_as3userdata(L, 1);

  if (userdata->value != AS3_Undefined())
  {
    AS3_Release(userdata->value);
    userdata->value = AS3_Undefined();
  }

  SPAM(("as3_release() : end"));

  LRETURN(L, stack, 0);
}

/*
* Convert ActionScript to a Lua type if possible (see push_as3_to_lua_stack).
* Supports multiple arguments.
* If conversion is not possible, this will return the original AS object.
* If argument is a Lua value, it is returned intact.</p>
* Lua example: as3.tolua(v)
*/
static int as3_tolua(lua_State * L)
{
  LCALL(L, stack);

  int i = 1;

  luaL_checkany(L, 1); /* Need at least one argument */

  lua_getfield(L, LUA_REGISTRYINDEX, AS3LUA_METATABLE);

  for (i = 1; i <= LBASE(L, stack); ++i)
  {
    void * userdata = lua_touserdata(L, i);
    if (userdata == NULL || !lua_getmetatable(L, i))
    {
      lua_pushvalue(L, i);
    }
    else if (!lua_rawequal(L, LBASE(L, stack) + 1, -1))
    {
      lua_pop(L, 1); /* Pop userdata metatable */
      lua_pushvalue(L, i);
    }
    else
    {
      AS3LuaUserData * as3_userdata = (AS3LuaUserData *)userdata;

      lua_pop(L, 1); /* Pop userdata metatable */
      push_as3_to_lua_stack(L, as3_userdata->value);
    }
  }

  lua_remove(L, LBASE(L, stack) + 1); /* Remove AS3LUA_METATABLE */

  LRETURN(L, stack, LBASE(L, stack));
}

/*
* Return the requested property of a given ActionScript object.  The value
* is returned as a Lua type if possible (see push_as3_to_lua_stack)
* Lua example: as3.get(v, "text")
*/
static int as3_get(lua_State * L)
{
  LCALL(L, stack);

  AS3LuaUserData * userdata = NULL;
  const char * property = NULL;
  AS3_Val val;

  userdata = check_as3userdata(L, 1);

  property = lua_tostring(L, 2);
  luaL_argcheck(L, property != NULL, 2, "'property' expected");

  val = AS3_GetS(userdata->value, property);
  /* TODO check for AS3_GetS successful */

  push_as3_to_lua_stack(L, val);

  AS3_Release(val);

  LRETURN(L, stack, 1);
}

/*
* Set the requested property of a given ActionScript object.
* Lua example: as3.set(v, "text", "hello from Lua")
*/
static int as3_set(lua_State * L)
{
  LCALL(L, stack);

  AS3LuaUserData * userdata = NULL;
  const char * property = NULL;
  AS3_Val value;

  userdata = check_as3userdata(L, 1);

  property = lua_tostring(L, 2);
  luaL_argcheck(L, property != NULL, 2, "'property' expected");

  value = get_as3_value_from_lua_stack(L, 3);
  luaL_argcheck(L, value != AS3_Undefined(), 3, "'value' expected");

  AS3_SetS(userdata->value, property, value);
  /* TODO check if AS3_SetS sucessful */

  LRETURN(L, stack, 0);
}

/*
* Set a primitive ActionScript value (like String, Number, etc)
* Lua example: as3.assign(v, 5)
*/
static int as3_assign(lua_State * L)
{
  LCALL(L, stack);

  AS3LuaUserData * userdata = 0;
  AS3_Val value;

  userdata = check_as3userdata(L, 1);

  value = get_as3_value_from_lua_stack(L, 2);
  luaL_argcheck(L, value != AS3_Undefined(), 2, "'value' expected");

  /* TODO how to assign the value of a String, Number, int, etc? var s:String; s = "hello"; and do we care? */

  LRETURN(L, stack, 0);
}

/*
* Call a function on a given ActionScript object
* Lua example: as3.call(v, "myFunction", "param1", param2, ...)
*/
static int as3_call(lua_State * L)
{
  LCALL(L, stack);

  AS3LuaUserData * userdata = NULL;
  AS3_Val params;
  const char * function_name = NULL;
  AS3_Val result;

  lua_pushnil(L); /* Hack to ensure we're not at empty stack */

  userdata = check_as3userdata(L, 1);

  function_name = lua_tostring(L, 2);
  luaL_argcheck(L, function_name != NULL, 2, "'function_name' expected");

  LCHECK(L, stack, 1);

  params = create_as3_value_from_lua_stack(L, 3, LBASE(L, stack), FALSE);

  LCHECK(L, stack, 1);

  result = AS3_CallS(function_name, userdata->value, params);
  /* TODO check for function call failure, make sure to relase params */
  if (LTOP(L, stack) == 0)
  {
    /* TODO: HACK. Lua state is not usable after panic! */
    fatal_error("as3_call(): callback error detected");
  }

  LCHECK(L, stack, 1);
  lua_pop(L, 1); /* Remove our protection from empty stack */

  AS3_Release(params);

#ifdef DO_SPAM
  SPAM(("as3_call() result type"));
  AS3_Trace(AS3_Call(getQualifiedClassName_method, NULL, AS3_Array("AS3ValType", result)));
#endif /* DO_SPAM */

  push_as3_to_lua_stack(L, result);

#ifdef DO_SPAM
  /* TODO: Remove */
  int top = lua_gettop(L);
  lua_pushcfunction(L, as3_trace);
  lua_pushliteral(L, "AS3_CALL()");
  Pdumpstack(L, top);
  lua_call(L, 2, 0);
#endif /* DO_SPAM */

  AS3_Release(result);

  LRETURN(L, stack, 1);
}

/*
* Return the ActionScript qualified name of the given object as a string
* Lua example: as3.type(v)
* Loosely based on io_type() from Lua 5.1.4
*/
static int as3_type(lua_State * L)
{
  LCALL(L, stack);

  void * userdata = NULL;

  luaL_checkany(L, 1);

  userdata = lua_touserdata(L, 1);

  lua_getfield(L, LUA_REGISTRYINDEX, AS3LUA_METATABLE);
  if (userdata == NULL || !lua_getmetatable(L, 1))
  {
    lua_pop(L, 1); /* Pop AS3LUA_METATABLE */
    lua_pushnil(L);
  }
  else if (!lua_rawequal(L, -2, -1))
  {
    lua_pop(L, 2); /* Pop AS3LUA_METATABLE and userdata metatable */
    lua_pushnil(L);
  }
  else
  {
    AS3LuaUserData * as3_userdata = NULL;
    AS3_Val result = NULL;
    AS3_Val params = NULL;

    lua_pop(L, 2); /* Pop AS3LUA_METATABLE and userdata metatable */

    as3_userdata = (AS3LuaUserData *)userdata;
    params = AS3_Array("AS3ValType", as3_userdata->value);
    result = AS3_Call(getQualifiedClassName_method, NULL, params);

    push_as3_to_lua_stack(L, result);

    AS3_Release(result);
    AS3_Release(params);
  }

  LRETURN(L, stack, 1);
}

/*
* Call a namespace function
* Can be used to call namespace functions
* Lua example: v = as3.package("flash.utils", "getQualifiedClassName")
*/
static int as3_namespacecall(lua_State * L)
{
  LCALL(L, stack);

  const char * namespace = NULL;
  const char * function_name = NULL;
  AS3_Val as_namespace;
  AS3_Val as_method;
  AS3_Val params;
  AS3_Val result;

  namespace = lua_tostring(L, 1);
  luaL_argcheck(L, namespace != NULL, 1, "'namespace' expected");

  function_name = lua_tostring(L, 2);
  luaL_argcheck(L, function_name != NULL, 2, "'function_name' expected");

  as_namespace = AS3_String(namespace);
  as_method = AS3_NSGetS(as_namespace, function_name);

  params = create_as3_value_from_lua_stack(L, 3, LBASE(L, stack), FALSE);

  result = AS3_Call(as_method, NULL, params);
  /* TODO check for function call failure, make sure to release as_namespace, as_method, params */

  push_as3_lua_userdata(L, result);

  AS3_Release(result);
  AS3_Release(as_namespace);
  AS3_Release(as_method);
  AS3_Release(params);

  LRETURN(L, stack, 1);
}

/*
* Adapted from Lua 5.1.4 luaB_print()
* NOTE: This function has string concatenation overhead due to forced \n in sztrace().
* If there is a fputs() analog, use it (and rewrite this function again, based on luaB_print).
*/
static int as3_trace(lua_State * L)
{
  LCALL(L, stack);
  int i;
  int n = LBASE(L, stack);

  luaL_Buffer b;
  luaL_buffinit(L, &b);

  lua_pushcfunction(L, luaB_tostring);
  for (i = 1; i <= n; i++)
  {
    if (i > 1)
    {
      luaL_addchar(&b, ' ');
    }

    const char * s = NULL;
    lua_pushvalue(L, -1);  /* function to be called */
    lua_pushvalue(L, i);   /* value to print */
    lua_call(L, 1, 1);
    s = lua_tostring(L, -1);  /* get result */
    if (s == NULL)
    {
      return luaL_error(
          L,
          LUA_QL("tostring") " must return a string to " LUA_QL("as3.trace")
        );
    }

    luaL_addvalue(&b);
  }

  luaL_pushresult(&b);
  sztrace((char *)lua_tostring(L, -1)); /* WARNING: Beware of embedded zeroes */
  lua_pop(L, 2); /* Pop concatenated string and luaB_tostring function */

  LRETURN(L, stack, 0);
}

/*
* AS function registry for Lua
*/
static const luaL_reg AS3_LUA_LIB[] =
{
  { "yield", as3_yield },
  { "stage", as3_stage },
  { "class", as3_class },
  { "new", as3_new },
  { "release", as3_release },
  { "tolua", as3_tolua },
  { "get", as3_get },
  { "set", as3_set },
  { "assign", as3_assign },
  { "call", as3_call },
  { "type", as3_type },
  { "namespacecall", as3_namespacecall },
  { "trace", as3_trace },
  { NULL, NULL } /* The end */
};

/*
* Creates the lua_state, opens the standard libs, and registers functions
*/
static lua_State * initialize_state()
{
  /* WARNING: Panic alert! Use L*_FN checkers here! */

  lua_State * L = lua_open();

  lua_atpanic(L, &panic_handler);

  LCALL(L, stack);

  lua_gc(L, LUA_GCSTOP, 0);  /* stop collector during initialization */

  luaL_openlibs(L);

  luaL_newmetatable(L, AS3LUA_METATABLE);
  lua_pushcfunction(L, as3_release);
  lua_setfield(L, -2, "__gc");

  lua_pop(L, 1); /* pop as3 metatable created above */

  LCHECK_FN(L, stack, 0, fatal_error);

  luaL_newmetatable(L, AS3LUA_CALLBACKMT);
  lua_pushcfunction(L, release_callback);
  lua_setfield(L, -2, "__gc");

  lua_pop(L, 1); /* pop callback metatable created above */

  LCHECK_FN(L, stack, 0, fatal_error);

  luaL_register(L, "as3", AS3_LUA_LIB);
  lua_pop(L, 1); /* pop as3 library table created by above call */

  LCHECK_FN(L, stack, 0, fatal_error);

  lua_newtable(L);
  lua_setfield(L, LUA_REGISTRYINDEX, AS3LUA_CALLBACKS);

  lua_gc(L, LUA_GCRESTART, 0); /* restart collector */

  LCHECK_FN(L, stack, 0, fatal_error);

  return L;
}

/*
* This function will be called at the top of the generated main().
* The GGINIT_DEFINED macro is required.
*/
#define GGINIT_DEFINED true
static void ggInit()
{
  /* setup some useful constants */
  no_params = AS3_Array("");
  zero_param = AS3_Int(0);
  Number_class = get_class("Number");
  int_class = get_class("int");
  String_class = get_class("String");
  Boolean_class = get_class("Boolean");
  flash_utils_namespace = AS3_String("flash.utils");
  getQualifiedClassName_method = AS3_NSGetS(flash_utils_namespace, "getQualifiedClassName");
  Array_class = get_class("Array");
}

/* end of passthru C section */
}

public function luaInitilizeState():(lua_State *)uint
{
  return initialize_state();
}

public function luaClose(luaState:(lua_State *)uint):void
{
  /* Note: Keep these traces. It is easy to get bad things happening in final GC */
  sztrace("luaClose() : begin");
  lua_close(luaState);
  sztrace("luaClose() : end");
}

public function luaDoString(luaState:(lua_State *)uint, strValue:(AS3_Val)*):(AS3_Val)Array
{
  /* WARNING: Panic alert! Use L*_FN checkers here! */

  lua_State * L = luaState;

  LCALL(L, stack);
  if (LBASE(L, stack) != 0)
  {
    LERROR(L, stack, "dirty state stack");
  }

  SPAM(("luaDoString(): begin"));

  int status = 0;
  AS3_Malloced_Str str = AS3_StringValue(strValue);
  AS3_Val res;

  lua_pushboolean(L, 1); /* Placeholder for execution status */

  status = luaL_loadbuffer(
      L,
      str,
      AS3_IntValue(AS3_GetS(strValue, "length")),
      "=luaDoString" /* TODO: Pass chunk name as an optional argument */
    );

  free(str);

  if (status == 0)
  {
    LCHECK_FN(L, stack, 2, fatal_error);
    SPAM(("luaDoString(): run begin"));
    status = do_pcall_with_traceback(L, 0, LUA_MULTRET);
    SPAM(("luaDoString(): run end"));
  }

  if (status != 0)
  {
    LCHECK_FN(L, stack, 2, fatal_error);

    {
      /* TODO: Overhead. Remove? */

      const char * msg = NULL;

      lua_pushvalue(L, -1); /* To preserve original value type */

      msg = lua_tostring(L, -1);
      if (msg == NULL)
      {
        msg = "(non-string)";
      }

      sztrace("luaDoString(): error:");
      sztrace((char *)msg);
      lua_pop(L, 1);
    }

    lua_pushboolean(L, 0); /* ERROR */
    lua_replace(L, 1);
    /* Error message is on stack */
    /* NOTE: It is not necessary string! */

    LCHECK_FN(L, stack, 2, fatal_error);
  }

  SPAM(("luaDoString(): before create_as3_value_from_lua_stack"));

  res = create_as3_value_from_lua_stack(
      L,
      1,
      LTOP(L, stack),
      FALSE
    );

  SPAM(("luaDoString(): after create_as3_value_from_lua_stack"));

  lua_pop(L, LEXTRA(L, stack)); /* Cleanup results */

  SPAM(("luaDoString(): end"));

  return res;
}

// TODO: Add luaDoStringThrow()?

public function setGlobal(luaState:(lua_State *)uint, key:String, value:(AS3_Val)*):void
{
  push_as3_to_lua_stack(luaState, value);
  lua_setglobal(luaState, key);
}
